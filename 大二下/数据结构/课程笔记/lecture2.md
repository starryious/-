# 性能评价

### 关于算法执行时间

**定义**: 一个算法的执行时间大致上等于其所有语句执行时间的总和, 对于语句的执行时间是指该条语句的执行次数和执行一次所需要时间的乘积.

**分析**: 由于算法的实际执行时间与机器硬件和系统软件有关, 我们对执行的次数进行比较. 即语句频度.

### 语句频度

**定义**: 语句频度是指该语句在一个算法中重复执行的次数.

**例如**: 两个 n × n 的矩阵相乘

```c
for (i=0;i<n;i++) /*执行 n 次*/
for (j=0;j<n;j++)  /*执行 n^2 次*/
	{
	c[i][j]=0;  /*执行 n^2 次*/
	for (k=0;k<n;k++)  /*执行 n^3 次*/
		c[i][j]=c[i][j]+a[i][k]+b[k][j];  /*执行 n^3 次*/
	}
```

总执行次数: T(n)=2n^3 + 2n^2 + n. 

在分析语句频度时, <u>当有大量代码时, 我们只需要关心嵌套在最里层的语句就可以分析出执行次数</u>.

### 算法的时间复杂度

**定义**: 即算法的时间度量, 以语句频度为量度.

O(1), 称为常量阶; O(n), 称为线性阶; O(n^2) 称为平方阶. 上述的例子是 O(n^3). 常用的还有 指数型: O(2^n), 对数型: O(log n), 二维型: O(n log n).

一般来说, 对数型, 线性型, 二维型可实现, 其他的虽然理论上可实现, 但当 N 大于5时已经十分大了.

### 最坏时间复杂度

**定义**: 讨论算法在最坏情况下的时间复杂度, 即分析最坏的情况下以估计出算法执行时间的上界.

**例如**: 冒泡排序算法

### 算法的空间复杂度

**定义**: 用空间复杂度作为算法所需存储空间的量度, 记作: S(n)=O(f(n))  

第一章内容完.

**例题1**:

```c
int fact(int n)
{
    if(n <= 1) return 1;
    else return n*fact(n-1)
}
```

复杂度为 O(n).

**例题2**:

```c
int i=1;
while (i <= n)
	i=i*2;
```

复杂度为 O(log_2 n)

****

# 第二章: 线性表

## 线性结构的特点:

数据元素的非空有限序列中, 存在唯一的首元素和唯一的尾元素, 首元素无直接前驱, 尾元素无直接后继, 其他每个数据元素均有唯一的直接前驱和唯一的直接后继.

### 线性表

**定义**: 线性表是 n 个类型相同的数据元素的有限序列.

**特点**: 

* 同一性: 线性表由同类数据元素组成, 每个元素必须属于同一数据对象.
* 有穷性: 线性表由有限个数据元素组成, 表长度就是表中数据元素的个数
* 有序性: 线性表中相邻数据元素之间存在着序偶关系 <ai,ai+1>

## 2.1.2 线性表的抽象数据类型定义

### 抽象数据类型定义:

ADT `LinearList`

数据元素:

结构关系:

基本操作:

* `InitList`: 初始化
* `DestoryList`: 销毁
* `ClearList`: 清空
* `EmptyList`: 为空则返回真, 否则为假
* `ListLength` : 为空返回0, 非空返回个数
* `Localte` 
* `GetData`
* `InsList`
* `DelList`

} ADT `LinearList`

## 2.2.1 顺序存储结构的定义

**定义**: 线性表的顺序存储时指用一组地址连续的存储单元依次存储线性表中的各个元素, 使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中, 即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系. 采用顺序存储结构的线性表通常称为 <u>顺序表</u> 

* 将顺序表归纳为: 关系线性化, 结点顺序存.

* 假设线性表中有 n 个元素, 每个元素占 k 个单元, 第一个元素的地址为 `loc(a1)`. 可以计算出第 i 个元素的地址
  $$
  loc(a_i)=loc(a_{1})+(i-1)\times k
  $$
  其中 `loc(a1)` 称为基地址.

## 2.2.2 顺序存储结构的C语言定义

```c
#define MAXSIZE 100
type struct
{
 ElemType elem[MAXSIZE];
 int last;
} SeqList;
```

`SeqList`结构体

### 线性表顺序存储结构的基本运算

* 查找操作

  
