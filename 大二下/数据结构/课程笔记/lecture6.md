# Lecture6

## 一元多项式的表示及相加

### 表示方式

一个一元多项式可以按照升幂的形式写成
$$
P_n(x)=p_0+p_1x+p_2x^2+\cdots+p_n x^n
$$
在计算机内, 可以用一个线性表 `P` 来表示:

```c
P=(p0,p1,...,pn)
```

用单链表存储多项式的结点结构如下:

```c
typedef struct Polynode {
int coef;
int exp;
Polynode *next;
} Polynode, *Polytlist
```

算法描述: 输入多项式的系数和指数, 用尾插法建立一元多项式的链表.

```c
Polylist polycreate()
{
    Polynode *head, *rear, *s;
    int c,e;
    h=(Polynode*)malloc(sizeof(Polynode));
    /* 建立多项式的头结点 */
    rear=head; /* rear始终指向单链表的尾,便于尾插法建表 */
    scanf("%d,%d,&c,&e");
    /* 键入多项式的系数和指数项 */
    while(c!=0)
        /* 若c=0, 则代表多项式的输入结束 */
    {
        s=(Polynode*)malloc(sizeof(Polynode))
            /* 申请新的结点*/
       s->coef=c;
       s->exp=e;
       rear->next=s; /* 在当前表尾做插入 */
       rear=s;
       scanf("%d,%d",&c,&e);
    }
    rear->next=NULL; /* 将表的最后一个结点的next置NULL, 以示表结束*/
	return(head);
}
```

添加

```c
void polyadd(Polylist polya, Polylist polyb)
{
    Polynode *p, *q, *tail; *tail;
    int sum
    p=polya->next;
    q=polyb->next;
}
```

### 顺序表与链表的综合比较

**基于空间的考虑**:

  顺序表的存储空间是静态分配的, 在程序执行之前必须明确规定它的存储规模. 在静态链表中, 初始存储池虽然也是静态分配的, 但若同时存在若干个结点类型相同的链表, 则它们可以共享空间, 动态链表的存储空间是动态分配的, 只要内存空间尚有空闲, 就不会产生溢出.
  因此, 当线性表的长度变化较大, 难以估计其存储规模时, 采用动态链表作为存储结构比较好.
  <u>存储密度</u>(Storage Density) 是指结点数据本身所占用的存储量和整个结点结构所占有的存储量之比, 一般地, 存储密度越大, 存储空间的利用率就越高, 显然, 顺序表的存储密度为1, 而链表的存储密度小于1.

**基于时间的考虑**:

  顺序表是由向量实现的, 它是一种随机存取结构, 对表中任一结点都可以在 `O(1)` 时间内直接地存取, 而链表中的结点, 需从头指针起顺着链才能取得. 因此, 若线性表的操作主要是进行**查找**, 很少做插入和删除时, **宜采用顺序表做存储结构**.

  在链表中的任何位置商进行插入和删除吗都只需要修改指针. 而在顺序表中进行插入和删除, 平均要移动表中近一半的结点, 尤其是当每个结点的信息量较大时, 移动结点的时间开销就相当可观. 因此, **对于频繁移进行插入和删除的线性表, 宜采用链表做存储结构**. 若表的插入和删除主要发生在表的首位两端, 则宜采用尾指针的单循环链表

**基于语言的考虑**:

有的语言没有链表

### 线性表链式存储方式的比较

| 链表名称/操作名称           | 找首元素结点         | 找表尾结点           | 找P结点前驱结点                    |
| --------------------------- | -------------------- | -------------------- | ---------------------------------- |
| 带头结点单链表              | L->next 时间耗费O(1) | 一重循环时间耗费O(n) | 顺P结点的next域无法找到P结点的前驱 |
| 带头结点循环单链表(头指针)L |                      |                      |                                    |
| 带尾指针的循环单链表R       |                      |                      |                                    |
| 带头结点双向循环链表L       |                      |                      |                                    |

**线性表的操作特点**

* <u>顺链操作结束</u>: 从"头"开始, 访问单链表`L` 中结点`i`(`p`指向该结点)时, 由于第 `i` 个结点的地址在第 `i-1`个结点(`pre` 指向该结点, 为 `p` 的前驱) 的指针域中存放, 查找必须从单链表的"首结点"开始(`p=L`): 通过 `p=->next` 并辅助计数器来实现
* <u>指针保留技术</u>: 对第 `i` 个结点进行插入, 删除等操作时, 要对第`i-1`个结点的指针域进行链址操作(`pre->next`), 因此在处理过程中始终需要维持当前指针 `p` 与其前驱指针 `pre` 的关系, 将着这种技术简称为 "指针保留技术".

**链表处理中的相关技术**

* 单链表与多重链表的差别在于<u>指针域的个数</u>
* 一般链表与循环链表的差别在于<u>是否首尾相接</u>, 将非空表, 空表等多种情况统一处理, 以方便运算
* 判断当前结点`p`是否为表尾: 一般链表中, `p` 结点是表尾的条件是: 该结点的后继指针值为空, 即 `p->next==NULL`, 循环链表中, `p` 结点是表尾结点的条件是: 该结点的后继指针为头指针即 `p->next==head`
* 链表的表长度 `n` 值并未显式保存: 由于链表是动态生成的结构, 其长度要通过顺链查找表尾得到. 因此在处理链表时, 往往以当前处理位置结点 `p` 是否为表尾作为控制条件.

****



## 第三章: 限定性线性表 -- 栈(stack)和队列

限定性指限制线性表插入和删除等运算的位置(只允许在端点位置操作)

### 3.1 栈

#### 3.1.1栈的定义

**栈的定义**: 把线性表的插入和删除运算限制在表的一端进行. 通常将表中允许进行运算端称为 <u>栈顶</u>(Top), 不允许运算的另一端被称为 <u>栈底</u>(Bottom). 由于栈顶位置是动态变化的, 需要设置栈顶指示器.

当栈中没有元素时称为<u>空栈</u>.

**栈的常见运算**: 进栈或入栈(表尾插入); 出栈或退栈(表尾删除)

**栈的特性**: 后进先出(LIFO)

[(23条消息) 不可能的出栈顺序_不可能的出栈序列_Keep_Moving2030的博客-CSDN博客](https://blog.csdn.net/u011982340/article/details/39249651)

**栈的抽象数据类型定义**:

* 数据元素: 可以是任意类型的数据, 但必须属于同一个数据对象
* 关系: 栈中数据元素之间是线性关系
* 基本操作: `IniStack(S)` `ClearStack(S)` `IsEmpty(S)` `IsFull(S)` `Push(S,x)` `Pop(S,x)` `GetTop(S,x)`

#### 3.1.2 栈的表示和实现

#### 3.1.3 栈的应用举例

#### 3.1.4 栈与递归的实现

### 3.2 队列

### 3.3 总结与提高

